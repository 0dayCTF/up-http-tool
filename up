#!/usr/bin/env python3
# Title: UP HTTP Server
# Author: AG | MuirlandOracle
# Date: 2022-09-26

import argparse
import os
import json
import sys
import waitress
import random
import netifaces
import colorsys
import threading
from rich.console import Console
from rich.columns import Columns
from rich.table import Table
from datetime import datetime
from flask import Flask, send_from_directory, request


# Mutex to protect the console should multiple requests come in simultaneously
mutex = threading.Lock()

##### Network Interface Interaction #####
class Interfaces():
    def __init__(self: object):
        self.currIP = ""
        self.interfaces = {}
        self.addresses = {}

        # Extract interfaces
        interfaces = netifaces.interfaces()
        for i in interfaces:
            interface = netifaces.ifaddresses(i).get(netifaces.AF_INET)
            if interface != None:
                currInterface = []
                for link in interface:
                    currInterface.append(link["addr"])
                    self.addresses[link["addr"]] = i
                self.interfaces[i] = currInterface

    def setAddress(self: object, addr: str="0.0.0.0") -> bool:
        if addr in self.interfaces.keys(): # i.e. did they submit a valid interface
            self.currIP = self.interfaces.get(addr)[0] # Select the first address from the interface
            return True
        elif addr in self.addresses.keys() or addr == "0.0.0.0": # i.e. they submitted an IP address
            self.currIP = addr
            return True
        else:
            return False
            

    def getPossibleAddresses(self: object) -> dict:
        if self.currIP == "":
            return {}
        elif self.currIP == "0.0.0.0":
            return self.interfaces
        else:
            return {self.addresses[self.currIP]: self.currIP}
    


##### Display Functions #####
def printInfo(directory=os.getcwd(), quiet=False, noServe=False):
    headerstyle = "\n[bold underline]{}[/bold underline]"
    c = Console(highlight=False)
    if not quiet:
        c.rule("Information")
    if not noServe: # No point in printing this if we're not serving files
        c.print(headerstyle.format("Directory"))
        c.print(directory)
        c.print(headerstyle.format("Files"))
        c.print(Columns(os.listdir(directory)))
    c.print(headerstyle.format("Interfaces"))
    for i in netifaces.interfaces():
        interface = netifaces.ifaddresses(i).get(netifaces.AF_INET)
        if interface != None:
            for link in interface:
                if link["addr"] != "127.0.0.1":
                    c.print(f"{i}: [italic]{link['addr']}[/ italic]")
    c.print()
    if not quiet:
        c.rule()

def renderTable(title: str, cols: list, arr: list):
    #t = Table(title=title, show_lines=True)
    t = Table(title=title)
    for i in cols:
        t.add_column(i, overflow="fold")
    for i in arr:
        t.add_row(*i)
    return t


##### HTTP Server #####
def getBody():
    if request.headers.get("Content-Type") == "application/json":
        try:
            data = request.json
        except:
            data = {}
    else:
        data = tuple([(k,v) for k,v in request.form.items()])
    return data

def createApp(servDir=os.getcwd(), debug=False, accessibleMode=False, noServe=False, noColourMode=False, addCors=True, resMsg=""):
    app = Flask(__name__)

    # Handle GET requests 
    @app.route("/", defaults={"path":""})
    @app.route('/<path:path>')
    def sendFile(path):
        if not noServe:
            return send_from_directory(servDir, path)
        else:
            return resMsg
            

    # Handle all other request methods
    @app.errorhandler(405)
    def catchall(e):
        return resMsg, 200
    
    # Relax SOP restrictions if requested  -- let's be honest, we don't need 'em anyway
    if addCors:
        @app.after_request
        def enableCors(r):
            r.headers["Access-Control-Allow-Origin"] = request.referrer  or "*"
            r.headers["Access-Control-Allow-Method"] = "*"
            r.headers["Access-Control-Allow-Credentials"] = "true"
            r.headers["Access-Control-Expose-Headers"] = "*"
            r.headers["Access-Control-Allow-Headers"] = "*"
            return r


    @app.after_request
    def printHeaders(r):
        mutex.acquire()
        # Shoutout @Sam1ser for this one -- https://github.com/Samiser/pfp-colour-changer/blob/main/main.py
        c = Console(style=f"rgb({','.join(str(round(i*255)) for i in colorsys.hsv_to_rgb(random.random(), 0.3, 0.95))})" if not noColourMode else "", highlight=False)
        c.print(f"""{"=============================================" + chr(10) if debug and not accessibleMode else ""}{request.remote_addr} - - [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] "{request.method} {request.full_path.rstrip('?')} {request.environ.get('SERVER_PROTOCOL')}" {r.status_code} -""")
        if debug:
            if not accessibleMode:
                c.print(renderTable("", ["Header", "Value"], request.headers))
            else:
                c.print("Headers:")
                for i in request.headers:
                    c.print(f" {i[0]}: {i[1]}")

            # Handle Data
            data = getBody()
            if len(data) > 0:
                c.print("[bold underline]Body:[/ bold underline]")
                if type(data) == dict:
                    c.print_json(data=data, highlight=(not noColourMode))
                elif not accessibleMode:
                    c.print(renderTable("", ["Key", "Value"], data))
                else:
                    for i in data:
                        c.print(f" {i[0]}: {i[1]}")


            # Handle query parameters
            args = tuple([(i,v) for i,v in request.args.items()])
            if len(args) > 0:
                c.print("[bold underline]Query Parameters:[/ bold underline]")
                if not accessibleMode:
                    c.print(renderTable("", ["Key", "Value"], args))
                else:
                    for i in args:
                        c.print(f" {i[0]}: {i[1]}")
            mutex.release()
        return r
    return app

##### Validator Functions #####
def validAddress(interfaces: Interfaces, addr: str="0.0.0.0"): # Validate that the requested IP address / interface is suitable to bind the server to
    if interfaces.setAddress(addr):
        return addr
    else:
        raise argparse.ArgumentTypeError(f"'{addr}' is not a valid IP address or interface  assigned to this machine") 
    


##### Start the App #####
if __name__ == "__main__":
    # Initialise Interfaces
    interfaces = Interfaces()

    # Arg Parsing
    parser = argparse.ArgumentParser(description="UP Simple HTTP server for debugging / hacking")
    parser.add_argument("-v", "--verbose", help="Show request headers / information (you probably want this active)", action="store_true")
    parser.add_argument("-q", "--quiet", help="Don't show information on startup", action="store_true")
    parser.add_argument("-p", "--port", help="The port to serve on. Defaults to port 80", default=80)
    parser.add_argument("-i", "--ip", help="The IP to serve on. Defaults to all interfaces (0.0.0.0)", default="0.0.0.0", type=lambda addr: validAddress(interfaces, addr))
    parser.add_argument("-m", "--msg", help="Message to respond to non-GET requests with. Defaults to ''.", default="")

    dirGrp = parser.add_mutually_exclusive_group() # Directory arguments
    dirGrp.add_argument("-d", "--directory", help="Directory to serve files from. Defaults to current working directory", default=os.getcwd())
    dirGrp.add_argument("--no-serve", help="Do not serve files", action="store_true")


    accessGrp = parser.add_mutually_exclusive_group() # Colour parsing -- if accessible is specified then they both must be, no point in allowing them both to be specified
    accessGrp.add_argument("--accessible", action="store_true", help="Disable ASCII art (automatically adds --no-colour)")
    accessGrp.add_argument("-c","--no-colour", action="store_true", help="Disable colour printing")

    parser.add_argument("-ec", "--enable-cors", help="Add headers to enable CORS (relax browser same-origin policy requirements)", action="store_true")

    args = parser.parse_args()

    if args.accessible:
        args.no_colour = True


    # Start app
    if not args.quiet:
        printInfo(args.directory, quiet=True, noServe=args.no_serve)
        print(f"Serving on http://{args.ip}:{args.port}")
    app = createApp(debug=args.verbose, 
                    servDir=args.directory, 
                    accessibleMode=args.accessible, 
                    noColourMode=args.no_colour, 
                    noServe=args.no_serve, 
                    addCors=args.enable_cors,
                    resMsg=args.msg)
    threading.Thread(target=lambda: waitress.serve(app, port=args.port, host=args.ip), daemon=True).start() # Run the HTTP server in the background so that the enter-for-info works
    while True:
        try:
            input()
        except KeyboardInterrupt:
            exit()
        printInfo(args.directory, quiet=args.accessible, noServe=args.no_serve)
