#!/usr/bin/env python3
# Title: UP HTTP Server
# Author: AG | MuirlandOracle
# Date: 2022-09-26

import argparse
import os
import json
import sys
import waitress
import random
import netifaces
import colorsys
import threading
from rich.console import Console
from rich.columns import Columns
from rich.table import Table
from datetime import datetime
from flask import Flask, send_from_directory, request


##### Display Functions #####
def printInfo(directory=os.getcwd(), quiet=False, noServe=False):
    headerstyle = "\n[bold underline]{}[/bold underline]"
    c = Console(highlight=False)
    if not quiet:
        c.rule("Information")
    if not noServe: # No point in printing this if we're not serving files
        c.print(headerstyle.format("Directory"))
        c.print(directory)
        c.print(headerstyle.format("Files"))
        c.print(Columns(os.listdir(directory)))
    c.print(headerstyle.format("Interfaces"))
    for i in netifaces.interfaces():
        interface = netifaces.ifaddresses(i).get(netifaces.AF_INET)
        if interface != None:
            for link in interface:
                if link["addr"] != "127.0.0.1":
                    c.print(f"{i}: [italic]{link['addr']}[/ italic]")
    c.print()
    if not quiet:
        c.rule()

def renderTable(title: str, cols: list, arr: list):
    #t = Table(title=title, show_lines=True)
    t = Table(title=title)
    for i in cols:
        t.add_column(i, overflow="fold")
    for i in arr:
        t.add_row(*i)
    return t


##### HTTP Server #####
def getBody():
    if request.headers.get("Content-Type") == "application/json":
        try:
            data = request.json
        except:
            data = {}
    else:
        data = tuple([(k,v) for k,v in request.form.items()])
    return data

def createApp(servDir=os.getcwd(), debug=False, accessibleMode=False, noServe=False, noColourMode=False):
    app = Flask(__name__)

    if not noServe:
        @app.route('/<path:path>')
        def sendFile(path):
            return send_from_directory(servDir, path)

    @app.after_request
    def printHeaders(r):
        # Shoutout @Sam1ser for this one -- https://github.com/Samiser/pfp-colour-changer/blob/main/main.py
        c = Console(style=f"rgb({','.join(str(round(i*255)) for i in colorsys.hsv_to_rgb(random.random(), 0.3, 0.95))})" if not noColourMode else "", highlight=False)
        c.print(f"""{"=============================================" + chr(10) if debug and not accessibleMode else ""}{request.remote_addr} - - [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] "{request.method} {request.full_path.rstrip('?')} {request.environ.get('SERVER_PROTOCOL')}" {r.status_code} -""")
        if debug:
            if not accessibleMode:
                c.print(renderTable("", ["Header", "Value"], request.headers))
            else:
                c.print("Headers:")
                for i in request.headers:
                    c.print(f" {i[0]}: {i[1]}")

            # Handle Data
            data = getBody()
            if len(data) > 0:
                c.print("[bold underline]Body:[/ bold underline]")
                if type(data) == dict:
                    c.print_json(data=data, highlight=(not noColourMode))
                elif not accessibleMode:
                    c.print(renderTable("", ["Key", "Value"], data))
                else:
                    for i in data:
                        c.print(f" {i[0]}: {i[1]}")


            # Handle query parameters
            args = tuple([(i,v) for i,v in request.args.items()])
            if len(args) > 0:
                c.print("[bold underline]Query Parameters:[/ bold underline]")
                if not accessibleMode:
                    c.print(renderTable("", ["Key", "Value"], args))
                else:
                    for i in data:
                        c.print(f" {i[0]}: {i[1]}")
        return r
    return app


##### Start the App #####
if __name__ == "__main__":
    # Arg Parsing
    parser = argparse.ArgumentParser(description="UP Simple HTTP server for debugging / hacking")
    parser.add_argument("-v", "--verbose", help="Show request headers / information (you probably want this active)", action="store_true")
    parser.add_argument("-q", "--quiet", help="Don't show information on startup", action="store_true")
    parser.add_argument("-p", "--port", help="The port to serve on. Defaults to port 80", default=80)

    dirGrp = parser.add_mutually_exclusive_group() # Directory arguments
    dirGrp.add_argument("-d", "--directory", help="Directory to serve files from. Defaults to current working directory", default=os.getcwd())
    dirGrp.add_argument("--no-serve", help="Do not serve files", action="store_true")


    accessGrp = parser.add_mutually_exclusive_group() # Colour parsing -- if accessible is specified then they both must be, no point in allowing them both to be specified
    accessGrp.add_argument("--accessible", action="store_true", help="Disable ASCII art (automatically adds --no-colour)")
    accessGrp.add_argument("-c","--no-colour", action="store_true", help="Disable colour printing")

    args = parser.parse_args()

    if args.accessible:
        args.no_colour = True


    # Start app
    if not args.quiet:
        printInfo(args.directory, quiet=True, noServe=args.no_serve)
        print(f"Serving on port {args.port}")
    app = createApp(debug=args.verbose, servDir=args.directory, accessibleMode=args.accessible, noColourMode=args.no_colour, noServe=args.no_serve)
    threading.Thread(target=lambda: waitress.serve(app, port=args.port, host="0.0.0.0"), daemon=True).start() # Run the HTTP server in the background so that the enter-for-info works
    while True:
        try:
            input()
        except KeyboardInterrupt:
            exit()
        printInfo(args.directory, quiet=args.accessible, noServe=args.no_serve)
