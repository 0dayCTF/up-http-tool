#!/usr/bin/env python3
# Title: UP HTTP Server
# Author: AG | MuirlandOracle
# Date: 2022-09-26

import argparse
import os
import json
import sys
import waitress
import random
import netifaces
import colorsys
import threading
from rich.console import Console
from rich.columns import Columns
from rich.table import Table
from datetime import datetime
from flask import Flask, send_from_directory, request


##### Display Functions #####
def printInfo(directory=os.getcwd(), quiet=False, noServe=False):
    headerstyle = "\n[bold underline]{}[/bold underline]"
    c = Console(highlight=False)
    if not quiet:
        c.rule("Information")
    if not noServe: # No point in printing this if we're not serving files
        c.print(headerstyle.format("Directory"))
        c.print(directory)
        c.print(headerstyle.format("Files"))
        c.print(Columns(os.listdir(directory)))
    c.print(headerstyle.format("Interfaces"))
    for i in netifaces.interfaces():
        interface = netifaces.ifaddresses(i).get(netifaces.AF_INET)
        if interface != None:
            for link in interface:
                if link["addr"] != "127.0.0.1":
                    c.print(f"{i}: [italic]{link['addr']}[/ italic]")
    c.print()
    if not quiet:
        c.rule()

def renderTable(title: str, cols: list, arr: list):
    #t = Table(title=title, show_lines=True)
    t = Table(title=title)
    for i in cols:
        t.add_column(i, overflow="fold")
    for i in arr:
        t.add_row(*i)
    return t


##### HTTP Server #####
def getBody():
    if request.headers.get("Content-Type") == "application/json":
        try:
            data = request.json
        except:
            data = {}
    else:
        data = tuple([(k,v) for k,v in request.form.items()])
    return data

def createApp(servDir=os.getcwd(), debug=False, accessibleMode=False, noServe=False, noColourMode=False):
    app = Flask(__name__)

    # Handle GET requests 
    @app.route("/", defaults={"path":""})
    @app.route('/<path:path>')
    def sendFile(path):
        if not noServe:
            return send_from_directory(servDir, path)
        else:
            return ""
            

    # Handle all other request methods
    @app.errorhandler(405)
    def catchall(e):
        return "Message Received", 200
    


    @app.after_request
    def printHeaders(r):
        # Shoutout @Sam1ser for this one -- https://github.com/Samiser/pfp-colour-changer/blob/main/main.py
        c = Console(style=f"rgb({','.join(str(round(i*255)) for i in colorsys.hsv_to_rgb(random.random(), 0.3, 0.95))})" if not noColourMode else "", highlight=False)
        c.print(f"""{"=============================================" + chr(10) if debug and not accessibleMode else ""}{request.remote_addr} - - [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] "{request.method} {request.full_path.rstrip('?')} {request.environ.get('SERVER_PROTOCOL')}" {r.status_code} -""")
        if debug:
            if not accessibleMode:
                c.print(renderTable("", ["Header", "Value"], request.headers))
            else:
                c.print("Headers:")
                for i in request.headers:
                    c.print(f" {i[0]}: {i[1]}")

            # Handle Data
            data = getBody()
            if len(data) > 0:
                c.print("[bold underline]Body:[/ bold underline]")
                if type(data) == dict:
                    c.print_json(data=data, highlight=(not noColourMode))
                elif not accessibleMode:
                    c.print(renderTable("", ["Key", "Value"], data))
                else:
                    for i in data:
                        c.print(f" {i[0]}: {i[1]}")


            # Handle query parameters
            args = tuple([(i,v) for i,v in request.args.items()])
            if len(args) > 0:
                c.print("[bold underline]Query Parameters:[/ bold underline]")
                if not accessibleMode:
                    c.print(renderTable("", ["Key", "Value"], args))
                else:
                    for i in args:
                        c.print(f" {i[0]}: {i[1]}")
        return r
    return app

##### Validator Functions #####
def validAddress(addr): # Validate that the requested IP address / interface is suitable to bind the server to
    interfaces = netifaces.interfaces() # Get all interfaces
    if addr == "0.0.0.0": # This is the default anyway...
        return addr
    elif addr in interfaces: # Check to see if the user specified a valid interface
        interface = netifaces.ifaddresses(addr).get(netifaces.AF_INET) # If so, grab a list of IPs assigned to the interface
        if interface == None: # If none, die
            raise argparse.ArgumentTypeError(f"'{addr}' does not have any valid IP addresses assigned to it") 
        else: # Return the first valid IP. If you've added more, that's your problem -- specify the damn address yourself
            return interface[0].get("addr")
    else: # It ain't the default, and it ain't an interface, so assume it's an address
        for i in interfaces:
            interface = netifaces.ifaddresses(i).get(netifaces.AF_INET)
            if interface != None: # If there are no addresses assigned, skip past this interface
                for link in interface:
                    if link["addr"] == addr:
                        return addr
    raise argparse.ArgumentTypeError(f"'{addr}' is not a valid IP address or interface  assigned to this machine") 
    


##### Start the App #####
if __name__ == "__main__":
    # Arg Parsing
    parser = argparse.ArgumentParser(description="UP Simple HTTP server for debugging / hacking")
    parser.add_argument("-v", "--verbose", help="Show request headers / information (you probably want this active)", action="store_true")
    parser.add_argument("-q", "--quiet", help="Don't show information on startup", action="store_true")
    parser.add_argument("-p", "--port", help="The port to serve on. Defaults to port 80", default=80)
    parser.add_argument("-i", "--ip", help="The IP to serve on. Defaults to all interfaces (0.0.0.0)", default="0.0.0.0", type=validAddress)

    dirGrp = parser.add_mutually_exclusive_group() # Directory arguments
    dirGrp.add_argument("-d", "--directory", help="Directory to serve files from. Defaults to current working directory", default=os.getcwd())
    dirGrp.add_argument("--no-serve", help="Do not serve files", action="store_true")


    accessGrp = parser.add_mutually_exclusive_group() # Colour parsing -- if accessible is specified then they both must be, no point in allowing them both to be specified
    accessGrp.add_argument("--accessible", action="store_true", help="Disable ASCII art (automatically adds --no-colour)")
    accessGrp.add_argument("-c","--no-colour", action="store_true", help="Disable colour printing")

    args = parser.parse_args()

    if args.accessible:
        args.no_colour = True


    # Start app
    if not args.quiet:
        printInfo(args.directory, quiet=True, noServe=args.no_serve)
        print(f"Serving on http://{args.ip}:{args.port}")
    app = createApp(debug=args.verbose, servDir=args.directory, accessibleMode=args.accessible, noColourMode=args.no_colour, noServe=args.no_serve)
    threading.Thread(target=lambda: waitress.serve(app, port=args.port, host=args.ip), daemon=True).start() # Run the HTTP server in the background so that the enter-for-info works
    while True:
        try:
            input()
        except KeyboardInterrupt:
            exit()
        printInfo(args.directory, quiet=args.accessible, noServe=args.no_serve)
